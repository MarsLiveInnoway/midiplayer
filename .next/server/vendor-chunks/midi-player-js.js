"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/midi-player-js";
exports.ids = ["vendor-chunks/midi-player-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/midi-player-js/build/index.js":
/*!****************************************************!*\
  !*** ./node_modules/midi-player-js/build/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * Constants used in player.\n */\nvar Constants = {\n  VERSION: '2.0.16',\n  NOTES: [],\n  HEADER_CHUNK_LENGTH: 14,\n  CIRCLE_OF_FOURTHS: ['C', 'F', 'Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb', 'Bbb', 'Ebb', 'Abb'],\n  CIRCLE_OF_FIFTHS: ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'E#']\n}; // Builds notes object for reference against binary values.\n\nvar allNotes = [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']];\nvar counter = 0; // All available octaves.\n\nvar _loop = function _loop(i) {\n  allNotes.forEach(function (noteGroup) {\n    noteGroup.forEach(function (note) {\n      return Constants.NOTES[counter] = note + i;\n    });\n    counter++;\n  });\n};\n\nfor (var i = -1; i <= 9; i++) {\n  _loop(i);\n}\n\n/**\n * Contains misc static utility methods.\n */\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    _classCallCheck(this, Utils);\n  }\n\n  _createClass(Utils, null, [{\n    key: \"byteToHex\",\n    value:\n    /**\n     * Converts a single byte to a hex string.\n     * @param {number} byte\n     * @return {string}\n     */\n    function byteToHex(_byte) {\n      // Ensure hex string always has two chars\n      return ('0' + _byte.toString(16)).slice(-2);\n    }\n    /**\n     * Converts an array of bytes to a hex string.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToHex\",\n    value: function bytesToHex(byteArray) {\n      var hex = [];\n      byteArray.forEach(function (_byte2) {\n        return hex.push(Utils.byteToHex(_byte2));\n      });\n      return hex.join('');\n    }\n    /**\n     * Converts a hex string to a number.\n     * @param {string} hexString\n     * @return {number}\n     */\n\n  }, {\n    key: \"hexToNumber\",\n    value: function hexToNumber(hexString) {\n      return parseInt(hexString, 16);\n    }\n    /**\n     * Converts an array of bytes to a number.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesToNumber\",\n    value: function bytesToNumber(byteArray) {\n      return Utils.hexToNumber(Utils.bytesToHex(byteArray));\n    }\n    /**\n     * Converts an array of bytes to letters.\n     * @param {array} byteArray\n     * @return {string}\n     */\n\n  }, {\n    key: \"bytesToLetters\",\n    value: function bytesToLetters(byteArray) {\n      var letters = [];\n      byteArray.forEach(function (_byte3) {\n        return letters.push(String.fromCharCode(_byte3));\n      });\n      return letters.join('');\n    }\n    /**\n     * Converts a decimal to it's binary representation.\n     * @param {number} dec\n     * @return {string}\n     */\n\n  }, {\n    key: \"decToBinary\",\n    value: function decToBinary(dec) {\n      return (dec >>> 0).toString(2);\n    }\n    /**\n     * Determines the length in bytes of a variable length quaantity.  The first byte in given range is assumed to be beginning of var length quantity.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"getVarIntLength\",\n    value: function getVarIntLength(byteArray) {\n      // Get byte count of delta VLV\n      // http://www.ccarh.org/courses/253/handout/vlv/\n      // If byte is greater or equal to 80h (128 decimal) then the next byte\n      // is also part of the VLV,\n      // else byte is the last byte in a VLV.\n      var currentByte = byteArray[0];\n      var byteCount = 1;\n\n      while (currentByte >= 128) {\n        currentByte = byteArray[byteCount];\n        byteCount++;\n      }\n\n      return byteCount;\n    }\n    /**\n     * Reads a variable length value.\n     * @param {array} byteArray\n     * @return {number}\n     */\n\n  }, {\n    key: \"readVarInt\",\n    value: function readVarInt(byteArray) {\n      var result = 0;\n      byteArray.forEach(function (number) {\n        var b = number;\n\n        if (b & 0x80) {\n          result += b & 0x7f;\n          result <<= 7;\n        } else {\n          /* b is the last byte */\n          result += b;\n        }\n      });\n      return result;\n    }\n    /**\n     * Decodes base-64 encoded string\n     * @param {string} string\n     * @return {string}\n     */\n\n  }, {\n    key: \"atob\",\n    value: function (_atob) {\n      function atob(_x) {\n        return _atob.apply(this, arguments);\n      }\n\n      atob.toString = function () {\n        return _atob.toString();\n      };\n\n      return atob;\n    }(function (string) {\n      if (typeof atob === 'function') return atob(string);\n      return Buffer.from(string, 'base64').toString('binary');\n    })\n  }]);\n\n  return Utils;\n}();\n\n/**\n * Class representing a track.  Contains methods for parsing events and keeping track of pointer.\n */\n\nvar Track = /*#__PURE__*/function () {\n  function Track(index, data) {\n    _classCallCheck(this, Track);\n\n    this.enabled = true;\n    this.eventIndex = 0;\n    this.pointer = 0;\n    this.lastTick = 0;\n    this.lastStatus = null;\n    this.index = index;\n    this.data = data;\n    this.delta = 0;\n    this.runningDelta = 0;\n    this.events = []; // Ensure last 3 bytes of track are End of Track event\n\n    var lastThreeBytes = this.data.subarray(this.data.length - 3, this.data.length);\n\n    if (!(lastThreeBytes[0] === 0xff && lastThreeBytes[1] === 0x2f && lastThreeBytes[2] === 0x00)) {\n      throw 'Invalid MIDI file; Last three bytes of track ' + this.index + 'must be FF 2F 00 to mark end of track';\n    }\n  }\n  /**\n   * Resets all stateful track informaion used during playback.\n   * @return {Track}\n   */\n\n\n  _createClass(Track, [{\n    key: \"reset\",\n    value: function reset() {\n      this.enabled = true;\n      this.eventIndex = 0;\n      this.pointer = 0;\n      this.lastTick = 0;\n      this.lastStatus = null;\n      this.delta = 0;\n      this.runningDelta = 0;\n      return this;\n    }\n    /**\n     * Sets this track to be enabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.enabled = true;\n      return this;\n    }\n    /**\n     * Sets this track to be disabled during playback.\n     * @return {Track}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n    /**\n     * Sets the track event index to the nearest event to the given tick.\n     * @param {number} tick\n     * @return {Track}\n     */\n\n  }, {\n    key: \"setEventIndexByTick\",\n    value: function setEventIndexByTick(tick) {\n      tick = tick || 0;\n\n      for (var i in this.events) {\n        if (this.events[i].tick >= tick) {\n          this.eventIndex = i;\n          return this;\n        }\n      }\n    }\n    /**\n     * Gets byte located at pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentByte\",\n    value: function getCurrentByte() {\n      return this.data[this.pointer];\n    }\n    /**\n     * Gets count of delta bytes and current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDeltaByteCount\",\n    value: function getDeltaByteCount() {\n      return Utils.getVarIntLength(this.data.subarray(this.pointer));\n    }\n    /**\n     * Get delta value at current pointer position.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getDelta\",\n    value: function getDelta() {\n      return Utils.readVarInt(this.data.subarray(this.pointer, this.pointer + this.getDeltaByteCount()));\n    }\n    /**\n     * Handles event within a given track starting at specified index\n     * @param {number} currentTick\n     * @param {boolean} dryRun - If true events will be parsed and returned regardless of time.\n     */\n\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(currentTick, dryRun) {\n      dryRun = dryRun || false;\n\n      if (dryRun) {\n        var elapsedTicks = currentTick - this.lastTick;\n        var delta = this.getDelta();\n        var eventReady = elapsedTicks >= delta;\n\n        if (this.pointer < this.data.length && (dryRun || eventReady)) {\n          var _event = this.parseEvent();\n\n          if (this.enabled) return _event; // Recursively call this function for each event ahead that has 0 delta time?\n        }\n      } else {\n        // Let's actually play the MIDI from the generated JSON events created by the dry run.\n        if (this.events[this.eventIndex] && this.events[this.eventIndex].tick <= currentTick) {\n          this.eventIndex++;\n          if (this.enabled) return this.events[this.eventIndex - 1];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get string data from event.\n     * @param {number} eventStartIndex\n     * @return {string}\n     */\n\n  }, {\n    key: \"getStringData\",\n    value: function getStringData(eventStartIndex) {\n      var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n      var varIntValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength));\n      var letters = Utils.bytesToLetters(this.data.subarray(eventStartIndex + 2 + varIntLength, eventStartIndex + 2 + varIntLength + varIntValue));\n      return letters;\n    }\n    /**\n     * Parses event into JSON and advances pointer for the track\n     * @return {object}\n     */\n\n  }, {\n    key: \"parseEvent\",\n    value: function parseEvent() {\n      var eventStartIndex = this.pointer + this.getDeltaByteCount();\n      var eventJson = {};\n      var deltaByteCount = this.getDeltaByteCount();\n      eventJson.track = this.index + 1;\n      eventJson.delta = this.getDelta();\n      this.lastTick = this.lastTick + eventJson.delta;\n      this.runningDelta += eventJson.delta;\n      eventJson.tick = this.runningDelta;\n      eventJson.byteIndex = this.pointer; //eventJson.raw = event;\n\n      if (this.data[eventStartIndex] == 0xff) {\n        // Meta Event\n        // If this is a meta event we should emit the data and immediately move to the next event\n        // otherwise if we let it run through the next cycle a slight delay will accumulate if multiple tracks\n        // are being played simultaneously\n        switch (this.data[eventStartIndex + 1]) {\n          case 0x00:\n            // Sequence Number\n            eventJson.name = 'Sequence Number';\n            break;\n\n          case 0x01:\n            // Text Event\n            eventJson.name = 'Text Event';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x02:\n            // Copyright Notice\n            eventJson.name = 'Copyright Notice';\n            break;\n\n          case 0x03:\n            // Sequence/Track Name\n            eventJson.name = 'Sequence/Track Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x04:\n            // Instrument Name\n            eventJson.name = 'Instrument Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x05:\n            // Lyric\n            eventJson.name = 'Lyric';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x06:\n            // Marker\n            eventJson.name = 'Marker';\n            break;\n\n          case 0x07:\n            // Cue Point\n            eventJson.name = 'Cue Point';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x09:\n            // Device Name\n            eventJson.name = 'Device Name';\n            eventJson.string = this.getStringData(eventStartIndex);\n            break;\n\n          case 0x20:\n            // MIDI Channel Prefix\n            eventJson.name = 'MIDI Channel Prefix';\n            break;\n\n          case 0x21:\n            // MIDI Port\n            eventJson.name = 'MIDI Port';\n            eventJson.data = Utils.bytesToNumber([this.data[eventStartIndex + 3]]);\n            break;\n\n          case 0x2F:\n            // End of Track\n            eventJson.name = 'End of Track';\n            break;\n\n          case 0x51:\n            // Set Tempo\n            eventJson.name = 'Set Tempo';\n            eventJson.data = Math.round(60000000 / Utils.bytesToNumber(this.data.subarray(eventStartIndex + 3, eventStartIndex + 6)));\n            this.tempo = eventJson.data;\n            break;\n\n          case 0x54:\n            // SMTPE Offset\n            eventJson.name = 'SMTPE Offset';\n            break;\n\n          case 0x58:\n            // Time Signature\n            // FF 58 04 nn dd cc bb\n            eventJson.name = 'Time Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 7);\n            eventJson.timeSignature = \"\" + eventJson.data[0] + \"/\" + Math.pow(2, eventJson.data[1]);\n            break;\n\n          case 0x59:\n            // Key Signature\n            // FF 59 02 sf mi\n            eventJson.name = 'Key Signature';\n            eventJson.data = this.data.subarray(eventStartIndex + 3, eventStartIndex + 5);\n\n            if (eventJson.data[0] >= 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FIFTHS[eventJson.data[0]];\n            } else if (eventJson.data[0] < 0) {\n              eventJson.keySignature = Constants.CIRCLE_OF_FOURTHS[Math.abs(eventJson.data[0])];\n            }\n\n            if (eventJson.data[1] == 0) {\n              eventJson.keySignature += \" Major\";\n            } else if (eventJson.data[1] == 1) {\n              eventJson.keySignature += \" Minor\";\n            }\n\n            break;\n\n          case 0x7F:\n            // Sequencer-Specific Meta-event\n            eventJson.name = 'Sequencer-Specific Meta-event';\n            break;\n\n          default:\n            eventJson.name = 'Unknown: ' + this.data[eventStartIndex + 1].toString(16);\n            break;\n        }\n\n        var varIntLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 2));\n        var length = Utils.readVarInt(this.data.subarray(eventStartIndex + 2, eventStartIndex + 2 + varIntLength)); //console.log(eventJson);\n\n        this.pointer += deltaByteCount + 3 + length; //console.log(eventJson);\n      } else if (this.data[eventStartIndex] === 0xf0) {\n        // Sysex\n        eventJson.name = 'Sysex';\n        var varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n        var varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + varQuantityByteLength));\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + varQuantityByteLength, eventStartIndex + 1 + varQuantityByteLength + varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + varQuantityByteLength + varQuantityByteValue;\n      } else if (this.data[eventStartIndex] === 0xf7) {\n        // Sysex (escape)\n        // http://www.somascape.org/midi/tech/mfile.html#sysex\n        eventJson.name = 'Sysex (escape)';\n\n        var _varQuantityByteLength = Utils.getVarIntLength(this.data.subarray(eventStartIndex + 1));\n\n        var _varQuantityByteValue = Utils.readVarInt(this.data.subarray(eventStartIndex + 1, eventStartIndex + 1 + _varQuantityByteLength));\n\n        eventJson.data = this.data.subarray(eventStartIndex + 1 + _varQuantityByteLength, eventStartIndex + 1 + _varQuantityByteLength + _varQuantityByteValue);\n        this.pointer += deltaByteCount + 1 + _varQuantityByteLength + _varQuantityByteValue;\n      } else {\n        // Voice event\n        if (this.data[eventStartIndex] < 0x80) {\n          // Running status\n          eventJson.running = true;\n          eventJson.noteNumber = this.data[eventStartIndex];\n          eventJson.noteName = Constants.NOTES[this.data[eventStartIndex]];\n          eventJson.velocity = this.data[eventStartIndex + 1];\n\n          if (this.lastStatus <= 0x8f) {\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0x9f) {\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.lastStatus <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 1;\n          } else if (this.lastStatus <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 2;\n          } else {\n            throw \"Unknown event (running): \".concat(this.lastStatus);\n          }\n        } else {\n          this.lastStatus = this.data[eventStartIndex];\n\n          if (this.data[eventStartIndex] <= 0x8f) {\n            // Note off\n            eventJson.name = 'Note off';\n            eventJson.channel = this.lastStatus - 0x80 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0x9f) {\n            // Note on\n            eventJson.name = 'Note on';\n            eventJson.channel = this.lastStatus - 0x90 + 1;\n            eventJson.noteNumber = this.data[eventStartIndex + 1];\n            eventJson.noteName = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.velocity = Math.round(this.data[eventStartIndex + 2] / 127 * 100);\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xaf) {\n            // Polyphonic Key Pressure\n            eventJson.name = 'Polyphonic Key Pressure';\n            eventJson.channel = this.lastStatus - 0xa0 + 1;\n            eventJson.note = Constants.NOTES[this.data[eventStartIndex + 1]];\n            eventJson.pressure = event[2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xbf) {\n            // Controller Change\n            eventJson.name = 'Controller Change';\n            eventJson.channel = this.lastStatus - 0xb0 + 1;\n            eventJson.number = this.data[eventStartIndex + 1];\n            eventJson.value = this.data[eventStartIndex + 2];\n            this.pointer += deltaByteCount + 3;\n          } else if (this.data[eventStartIndex] <= 0xcf) {\n            // Program Change\n            eventJson.name = 'Program Change';\n            eventJson.channel = this.lastStatus - 0xc0 + 1;\n            eventJson.value = this.data[eventStartIndex + 1];\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xdf) {\n            // Channel Key Pressure\n            eventJson.name = 'Channel Key Pressure';\n            eventJson.channel = this.lastStatus - 0xd0 + 1;\n            this.pointer += deltaByteCount + 2;\n          } else if (this.data[eventStartIndex] <= 0xef) {\n            // Pitch Bend\n            eventJson.name = 'Pitch Bend';\n            eventJson.channel = this.lastStatus - 0xe0 + 1;\n            this.pointer += deltaByteCount + 3;\n          } else {\n            throw \"Unknown event: \".concat(this.data[eventStartIndex]); //eventJson.name = `Unknown.  Pointer: ${this.pointer.toString()}, ${eventStartIndex.toString()}, ${this.data[eventStartIndex]}, ${this.data.length}`;\n          }\n        }\n      }\n\n      this.delta += eventJson.delta;\n      this.events.push(eventJson);\n      return eventJson;\n    }\n    /**\n     * Returns true if pointer has reached the end of the track.\n     * @param {boolean}\n     */\n\n  }, {\n    key: \"endOfTrack\",\n    value: function endOfTrack() {\n      if (this.data[this.pointer + 1] == 0xff && this.data[this.pointer + 2] == 0x2f && this.data[this.pointer + 3] == 0x00) {\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return Track;\n}();\n\nif (!Uint8Array.prototype.forEach) {\n  Object.defineProperty(Uint8Array.prototype, 'forEach', {\n    value: Array.prototype.forEach\n  });\n}\n/**\n * Main player class.  Contains methods to load files, start, stop.\n * @param {function} - Callback to fire for each MIDI event.  Can also be added with on('midiEvent', fn)\n * @param {array} - Array buffer of MIDI file (optional).\n */\n\n\nvar Player = /*#__PURE__*/function () {\n  function Player(eventHandler, buffer) {\n    _classCallCheck(this, Player);\n\n    this.sampleRate = 5; // milliseconds\n\n    this.startTime = 0;\n    this.buffer = buffer || null;\n    this.midiChunksByteLength = null;\n    this.division;\n    this.format;\n    this.setIntervalId = false;\n    this.tracks = [];\n    this.instruments = [];\n    this.defaultTempo = 120;\n    this.tempo = null;\n    this.startTick = 0;\n    this.tick = 0;\n    this.lastTick = null;\n    this.inLoop = false;\n    this.totalTicks = 0;\n    this.events = [];\n    this.totalEvents = 0;\n    this.eventListeners = {};\n    if (typeof eventHandler === 'function') this.on('midiEvent', eventHandler);\n  }\n  /**\n   * Load a file into the player (Node.js only).\n   * @param {string} path - Path of file.\n   * @return {Player}\n   */\n\n\n  _createClass(Player, [{\n    key: \"loadFile\",\n    value: function loadFile(path) {\n      {\n        var fs = __webpack_require__(/*! fs */ \"fs\");\n\n        this.buffer = fs.readFileSync(path);\n        return this.fileLoaded();\n      }\n    }\n    /**\n     * Load an array buffer into the player.\n     * @param {array} arrayBuffer - Array buffer of file to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadArrayBuffer\",\n    value: function loadArrayBuffer(arrayBuffer) {\n      this.buffer = new Uint8Array(arrayBuffer);\n      return this.fileLoaded();\n    }\n    /**\n     * Load a data URI into the player.\n     * @param {string} dataUri - Data URI to be loaded.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"loadDataUri\",\n    value: function loadDataUri(dataUri) {\n      // convert base64 to raw binary data held in a string.\n      // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n      var byteString = Utils.atob(dataUri.split(',')[1]); // write the bytes of the string to an ArrayBuffer\n\n      var ia = new Uint8Array(byteString.length);\n\n      for (var i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n      }\n\n      this.buffer = ia;\n      return this.fileLoaded();\n    }\n    /**\n     * Get filesize of loaded file in number of bytes.\n     * @return {number} - The filesize.\n     */\n\n  }, {\n    key: \"getFilesize\",\n    value: function getFilesize() {\n      return this.buffer ? this.buffer.length : 0;\n    }\n    /**\n     * Sets default tempo, parses file for necessary information, and does a dry run to calculate total length.\n     * Populates this.events & this.totalTicks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"fileLoaded\",\n    value: function fileLoaded() {\n      if (!this.validate()) throw 'Invalid MIDI file; should start with MThd';\n      return this.setTempo(this.defaultTempo).getDivision().getFormat().getTracks().dryRun();\n    }\n    /**\n     * Validates file using simple means - first four bytes should == MThd.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      //console.log((this.buffer.subarray(0, 15)));\n      return Utils.bytesToLetters(this.buffer.subarray(0, 4)) === 'MThd';\n    }\n    /**\n     * Gets MIDI file format for loaded file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getFormat\",\n    value: function getFormat() {\n      /*\n      MIDI files come in 3 variations:\n      Format 0 which contain a single track\n      Format 1 which contain one or more simultaneous tracks\n      (ie all tracks are to be played simultaneously).\n      Format 2 which contain one or more independant tracks\n      (ie each track is to be played independantly of the others).\n      return Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      */\n      this.format = Utils.bytesToNumber(this.buffer.subarray(8, 10));\n      return this;\n    }\n    /**\n     * Parses out tracks, places them in this.tracks and initializes this.pointers\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getTracks\",\n    value: function getTracks() {\n      this.tracks = [];\n      var trackOffset = 0;\n\n      while (trackOffset < this.buffer.length) {\n        if (Utils.bytesToLetters(this.buffer.subarray(trackOffset, trackOffset + 4)) == 'MTrk') {\n          var trackLength = Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8));\n          this.tracks.push(new Track(this.tracks.length, this.buffer.subarray(trackOffset + 8, trackOffset + 8 + trackLength)));\n        }\n\n        trackOffset += Utils.bytesToNumber(this.buffer.subarray(trackOffset + 4, trackOffset + 8)) + 8;\n      } // Get sum of all MIDI chunks here while we're at it\n\n\n      var trackChunksByteLength = 0;\n      this.tracks.forEach(function (track) {\n        trackChunksByteLength += 8 + track.data.length;\n      });\n      this.midiChunksByteLength = Constants.HEADER_CHUNK_LENGTH + trackChunksByteLength;\n      return this;\n    }\n    /**\n     * Enables a track for playing.\n     * @param {number} trackNumber - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"enableTrack\",\n    value: function enableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].enable();\n      return this;\n    }\n    /**\n     * Disables a track for playing.\n     * @param {number} - Track number\n     * @return {Player}\n     */\n\n  }, {\n    key: \"disableTrack\",\n    value: function disableTrack(trackNumber) {\n      this.tracks[trackNumber - 1].disable();\n      return this;\n    }\n    /**\n     * Gets quarter note division of loaded MIDI file.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"getDivision\",\n    value: function getDivision() {\n      this.division = Utils.bytesToNumber(this.buffer.subarray(12, Constants.HEADER_CHUNK_LENGTH));\n      return this;\n    }\n    /**\n     * The main play loop.\n     * @param {boolean} - Indicates whether or not this is being called simply for parsing purposes.  Disregards timing if so.\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"playLoop\",\n    value: function playLoop(dryRun) {\n      if (!this.inLoop) {\n        this.inLoop = true;\n        this.tick = this.getCurrentTick();\n        this.tracks.forEach(function (track, index) {\n          // Handle next event\n          if (!dryRun && this.endOfFile()) {\n            //console.log('end of file')\n            this.triggerPlayerEvent('endOfFile');\n            this.stop();\n          } else {\n            var event = track.handleEvent(this.tick, dryRun);\n\n            if (dryRun && event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.defaultTempo = event.data;\n                this.setTempo(event.data);\n              }\n\n              if (event.hasOwnProperty('name') && event.name === 'Program Change') {\n                if (!this.instruments.includes(event.value)) {\n                  this.instruments.push(event.value);\n                }\n              }\n            } else if (event) {\n              if (event.hasOwnProperty('name') && event.name === 'Set Tempo') {\n                // Grab tempo if available.\n                this.setTempo(event.data);\n\n                if (this.isPlaying()) {\n                  this.pause().play();\n                }\n              }\n\n              this.emitEvent(event);\n            }\n          }\n        }, this);\n        if (!dryRun) this.triggerPlayerEvent('playing', {\n          tick: this.tick\n        });\n        this.inLoop = false;\n      }\n    }\n    /**\n     * Setter for tempo.\n     * @param {number} - Tempo in bpm (defaults to 120)\n     */\n\n  }, {\n    key: \"setTempo\",\n    value: function setTempo(tempo) {\n      this.tempo = tempo;\n      return this;\n    }\n    /**\n     * Setter for startTime.\n     * @param {number} - UTC timestamp\n     * @return {Player}\n     */\n\n  }, {\n    key: \"setStartTime\",\n    value: function setStartTime(startTime) {\n      this.startTime = startTime;\n      return this;\n    }\n    /**\n     * Start playing loaded MIDI file if not already playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isPlaying()) throw 'Already playing...'; // Initialize\n\n      if (!this.startTime) this.startTime = new Date().getTime(); // Start play loop\n      //window.requestAnimationFrame(this.playLoop.bind(this));\n\n      this.setIntervalId = setInterval(this.playLoop.bind(this), this.sampleRate); //this.setIntervalId = this.loop();\n\n      return this;\n    }\n  }, {\n    key: \"loop\",\n    value: function loop() {\n      setTimeout(function () {\n        // Do Something Here\n        this.playLoop(); // Then recall the parent function to\n        // create a recursive loop.\n\n        this.loop();\n      }.bind(this), this.sampleRate);\n    }\n    /**\n     * Pauses playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = this.tick;\n      this.startTime = 0;\n      return this;\n    }\n    /**\n     * Stops playback if playing.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this.setIntervalId);\n      this.setIntervalId = false;\n      this.startTick = 0;\n      this.startTime = 0;\n      this.resetTracks();\n      return this;\n    }\n    /**\n     * Skips player pointer to specified tick.\n     * @param {number} - Tick to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToTick\",\n    value: function skipToTick(tick) {\n      this.stop();\n      this.startTick = tick; // Need to set track event indexes to the nearest possible event to the specified tick.\n\n      this.tracks.forEach(function (track) {\n        track.setEventIndexByTick(tick);\n      });\n      return this;\n    }\n    /**\n     * Skips player pointer to specified percentage.\n     * @param {number} - Percent value in integer format.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToPercent\",\n    value: function skipToPercent(percent) {\n      if (percent < 0 || percent > 100) throw \"Percent must be number between 1 and 100.\";\n      this.skipToTick(Math.round(percent / 100 * this.totalTicks));\n      return this;\n    }\n    /**\n     * Skips player pointer to specified seconds.\n     * @param {number} - Seconds to skip to.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"skipToSeconds\",\n    value: function skipToSeconds(seconds) {\n      var songTime = this.getSongTime();\n      if (seconds < 0 || seconds > songTime) throw seconds + \" seconds not within song time of \" + songTime;\n      this.skipToPercent(seconds / songTime * 100);\n      return this;\n    }\n    /**\n     * Checks if player is playing\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isPlaying\",\n    value: function isPlaying() {\n      return this.setIntervalId > 0 || _typeof(this.setIntervalId) === 'object';\n    }\n    /**\n     * Plays the loaded MIDI file without regard for timing and saves events in this.events.  Essentially used as a parser.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"dryRun\",\n    value: function dryRun() {\n      // Reset tracks first\n      this.resetTracks();\n\n      while (!this.endOfFile()) {\n        this.playLoop(true); //console.log(this.bytesProcessed(), this.midiChunksByteLength);\n      }\n\n      this.events = this.getEvents();\n      this.totalEvents = this.getTotalEvents();\n      this.totalTicks = this.getTotalTicks();\n      this.startTick = 0;\n      this.startTime = 0; // Leave tracks in pristine condish\n\n      this.resetTracks(); //console.log('Song time: ' + this.getSongTime() + ' seconds / ' + this.totalTicks + ' ticks.');\n\n      this.triggerPlayerEvent('fileLoaded', this);\n      return this;\n    }\n    /**\n     * Resets play pointers for all tracks.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"resetTracks\",\n    value: function resetTracks() {\n      this.tracks.forEach(function (track) {\n        return track.reset();\n      });\n      return this;\n    }\n    /**\n     * Gets an array of events grouped by track.\n     * @return {array}\n     */\n\n  }, {\n    key: \"getEvents\",\n    value: function getEvents() {\n      return this.tracks.map(function (track) {\n        return track.events;\n      });\n    }\n    /**\n     * Gets total number of ticks in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalTicks\",\n    value: function getTotalTicks() {\n      return Math.max.apply(null, this.tracks.map(function (track) {\n        return track.delta;\n      }));\n    }\n    /**\n     * Gets total number of events in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getTotalEvents\",\n    value: function getTotalEvents() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          events: {\n            length: a.events.length + b.events.length\n          }\n        };\n      }, {\n        events: {\n          length: 0\n        }\n      }).events.length;\n    }\n    /**\n     * Gets song duration in seconds.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTime\",\n    value: function getSongTime() {\n      return this.totalTicks / this.division / this.tempo * 60;\n    }\n    /**\n     * Gets remaining number of seconds in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongTimeRemaining\",\n    value: function getSongTimeRemaining() {\n      return Math.round((this.totalTicks - this.getCurrentTick()) / this.division / this.tempo * 60);\n    }\n    /**\n     * Gets remaining percent of playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getSongPercentRemaining\",\n    value: function getSongPercentRemaining() {\n      return Math.round(this.getSongTimeRemaining() / this.getSongTime() * 100);\n    }\n    /**\n     * Number of bytes processed in the loaded MIDI file.\n     * @return {number}\n     */\n\n  }, {\n    key: \"bytesProcessed\",\n    value: function bytesProcessed() {\n      return Constants.HEADER_CHUNK_LENGTH + this.tracks.length * 8 + this.tracks.reduce(function (a, b) {\n        return {\n          pointer: a.pointer + b.pointer\n        };\n      }, {\n        pointer: 0\n      }).pointer;\n    }\n    /**\n     * Number of events played up to this point.\n     * @return {number}\n     */\n\n  }, {\n    key: \"eventsPlayed\",\n    value: function eventsPlayed() {\n      return this.tracks.reduce(function (a, b) {\n        return {\n          eventIndex: a.eventIndex + b.eventIndex\n        };\n      }, {\n        eventIndex: 0\n      }).eventIndex;\n    }\n    /**\n     * Determines if the player pointer has reached the end of the loaded MIDI file.\n     * Used in two ways:\n     * 1. If playing result is based on loaded JSON events.\n     * 2. If parsing (dryRun) it's based on the actual buffer length vs bytes processed.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"endOfFile\",\n    value: function endOfFile() {\n      if (this.isPlaying()) {\n        return this.totalTicks - this.tick <= 0;\n      }\n\n      return this.bytesProcessed() >= this.midiChunksByteLength; //this.buffer.length;\n    }\n    /**\n     * Gets the current tick number in playback.\n     * @return {number}\n     */\n\n  }, {\n    key: \"getCurrentTick\",\n    value: function getCurrentTick() {\n      if (!this.startTime) return this.startTick;\n      return Math.round((new Date().getTime() - this.startTime) / 1000 * (this.division * (this.tempo / 60))) + this.startTick;\n    }\n    /**\n     * Sends MIDI event out to listener.\n     * @param {object}\n     * @return {Player}\n     */\n\n  }, {\n    key: \"emitEvent\",\n    value: function emitEvent(event) {\n      this.triggerPlayerEvent('midiEvent', event);\n      return this;\n    }\n    /**\n     * Subscribes events to listeners\n     * @param {string} - Name of event to subscribe to.\n     * @param {function} - Callback to fire when event is broadcast.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(playerEvent, fn) {\n      if (!this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent] = [];\n      this.eventListeners[playerEvent].push(fn);\n      return this;\n    }\n    /**\n     * Broadcasts event to trigger subscribed callbacks.\n     * @param {string} - Name of event.\n     * @param {object} - Data to be passed to subscriber callback.\n     * @return {Player}\n     */\n\n  }, {\n    key: \"triggerPlayerEvent\",\n    value: function triggerPlayerEvent(playerEvent, data) {\n      if (this.eventListeners.hasOwnProperty(playerEvent)) this.eventListeners[playerEvent].forEach(function (fn) {\n        return fn(data || {});\n      });\n      return this;\n    }\n  }]);\n\n  return Player;\n}();\n\nvar index = {\n  Player: Player,\n  Utils: Utils,\n  Constants: Constants\n};\n\nmodule.exports = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWlkaS1wbGF5ZXItanMvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0hBQW9IOztBQUVwSCxxREFBcUQ7QUFDckQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL2hvbWUvcHJvamVjdC9ub2RlX21vZHVsZXMvbWlkaS1wbGF5ZXItanMvYnVpbGQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogQ29uc3RhbnRzIHVzZWQgaW4gcGxheWVyLlxuICovXG52YXIgQ29uc3RhbnRzID0ge1xuICBWRVJTSU9OOiAnMi4wLjE2JyxcbiAgTk9URVM6IFtdLFxuICBIRUFERVJfQ0hVTktfTEVOR1RIOiAxNCxcbiAgQ0lSQ0xFX09GX0ZPVVJUSFM6IFsnQycsICdGJywgJ0JiJywgJ0ViJywgJ0FiJywgJ0RiJywgJ0diJywgJ0NiJywgJ0ZiJywgJ0JiYicsICdFYmInLCAnQWJiJ10sXG4gIENJUkNMRV9PRl9GSUZUSFM6IFsnQycsICdHJywgJ0QnLCAnQScsICdFJywgJ0InLCAnRiMnLCAnQyMnLCAnRyMnLCAnRCMnLCAnQSMnLCAnRSMnXVxufTsgLy8gQnVpbGRzIG5vdGVzIG9iamVjdCBmb3IgcmVmZXJlbmNlIGFnYWluc3QgYmluYXJ5IHZhbHVlcy5cblxudmFyIGFsbE5vdGVzID0gW1snQyddLCBbJ0MjJywgJ0RiJ10sIFsnRCddLCBbJ0QjJywgJ0ViJ10sIFsnRSddLCBbJ0YnXSwgWydGIycsICdHYiddLCBbJ0cnXSwgWydHIycsICdBYiddLCBbJ0EnXSwgWydBIycsICdCYiddLCBbJ0InXV07XG52YXIgY291bnRlciA9IDA7IC8vIEFsbCBhdmFpbGFibGUgb2N0YXZlcy5cblxudmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICBhbGxOb3Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub3RlR3JvdXApIHtcbiAgICBub3RlR3JvdXAuZm9yRWFjaChmdW5jdGlvbiAobm90ZSkge1xuICAgICAgcmV0dXJuIENvbnN0YW50cy5OT1RFU1tjb3VudGVyXSA9IG5vdGUgKyBpO1xuICAgIH0pO1xuICAgIGNvdW50ZXIrKztcbiAgfSk7XG59O1xuXG5mb3IgKHZhciBpID0gLTE7IGkgPD0gOTsgaSsrKSB7XG4gIF9sb29wKGkpO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIG1pc2Mgc3RhdGljIHV0aWxpdHkgbWV0aG9kcy5cbiAqL1xudmFyIFV0aWxzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVXRpbHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFV0aWxzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVdGlscywgbnVsbCwgW3tcbiAgICBrZXk6IFwiYnl0ZVRvSGV4XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzaW5nbGUgYnl0ZSB0byBhIGhleCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYnl0ZVRvSGV4KF9ieXRlKSB7XG4gICAgICAvLyBFbnN1cmUgaGV4IHN0cmluZyBhbHdheXMgaGFzIHR3byBjaGFyc1xuICAgICAgcmV0dXJuICgnMCcgKyBfYnl0ZS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYXJyYXkgb2YgYnl0ZXMgdG8gYSBoZXggc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGJ5dGVBcnJheVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJ5dGVzVG9IZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlQXJyYXkpIHtcbiAgICAgIHZhciBoZXggPSBbXTtcbiAgICAgIGJ5dGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChfYnl0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGhleC5wdXNoKFV0aWxzLmJ5dGVUb0hleChfYnl0ZTIpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhleC5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHJpbmdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoZXhUb051bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoZXhUb051bWJlcihoZXhTdHJpbmcpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChoZXhTdHJpbmcsIDE2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYW4gYXJyYXkgb2YgYnl0ZXMgdG8gYSBudW1iZXIuXG4gICAgICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnl0ZXNUb051bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVBcnJheSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmhleFRvTnVtYmVyKFV0aWxzLmJ5dGVzVG9IZXgoYnl0ZUFycmF5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGJ5dGVzIHRvIGxldHRlcnMuXG4gICAgICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYnl0ZXNUb0xldHRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnl0ZXNUb0xldHRlcnMoYnl0ZUFycmF5KSB7XG4gICAgICB2YXIgbGV0dGVycyA9IFtdO1xuICAgICAgYnl0ZUFycmF5LmZvckVhY2goZnVuY3Rpb24gKF9ieXRlMykge1xuICAgICAgICByZXR1cm4gbGV0dGVycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoX2J5dGUzKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBsZXR0ZXJzLmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRlY2ltYWwgdG8gaXQncyBiaW5hcnkgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlY1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImRlY1RvQmluYXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY1RvQmluYXJ5KGRlYykge1xuICAgICAgcmV0dXJuIChkZWMgPj4+IDApLnRvU3RyaW5nKDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBsZW5ndGggaW4gYnl0ZXMgb2YgYSB2YXJpYWJsZSBsZW5ndGggcXVhYW50aXR5LiAgVGhlIGZpcnN0IGJ5dGUgaW4gZ2l2ZW4gcmFuZ2UgaXMgYXNzdW1lZCB0byBiZSBiZWdpbm5pbmcgb2YgdmFyIGxlbmd0aCBxdWFudGl0eS5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBieXRlQXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYXJJbnRMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFySW50TGVuZ3RoKGJ5dGVBcnJheSkge1xuICAgICAgLy8gR2V0IGJ5dGUgY291bnQgb2YgZGVsdGEgVkxWXG4gICAgICAvLyBodHRwOi8vd3d3LmNjYXJoLm9yZy9jb3Vyc2VzLzI1My9oYW5kb3V0L3Zsdi9cbiAgICAgIC8vIElmIGJ5dGUgaXMgZ3JlYXRlciBvciBlcXVhbCB0byA4MGggKDEyOCBkZWNpbWFsKSB0aGVuIHRoZSBuZXh0IGJ5dGVcbiAgICAgIC8vIGlzIGFsc28gcGFydCBvZiB0aGUgVkxWLFxuICAgICAgLy8gZWxzZSBieXRlIGlzIHRoZSBsYXN0IGJ5dGUgaW4gYSBWTFYuXG4gICAgICB2YXIgY3VycmVudEJ5dGUgPSBieXRlQXJyYXlbMF07XG4gICAgICB2YXIgYnl0ZUNvdW50ID0gMTtcblxuICAgICAgd2hpbGUgKGN1cnJlbnRCeXRlID49IDEyOCkge1xuICAgICAgICBjdXJyZW50Qnl0ZSA9IGJ5dGVBcnJheVtieXRlQ291bnRdO1xuICAgICAgICBieXRlQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ5dGVDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSB2YXJpYWJsZSBsZW5ndGggdmFsdWUuXG4gICAgICogQHBhcmFtIHthcnJheX0gYnl0ZUFycmF5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFZhckludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkVmFySW50KGJ5dGVBcnJheSkge1xuICAgICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgICBieXRlQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyO1xuXG4gICAgICAgIGlmIChiICYgMHg4MCkge1xuICAgICAgICAgIHJlc3VsdCArPSBiICYgMHg3ZjtcbiAgICAgICAgICByZXN1bHQgPDw9IDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyogYiBpcyB0aGUgbGFzdCBieXRlICovXG4gICAgICAgICAgcmVzdWx0ICs9IGI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImF0b2JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKF9hdG9iKSB7XG4gICAgICBmdW5jdGlvbiBhdG9iKF94KSB7XG4gICAgICAgIHJldHVybiBfYXRvYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBhdG9iLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2F0b2IudG9TdHJpbmcoKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhdG9iO1xuICAgIH0oZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gYXRvYihzdHJpbmcpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cmluZywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9KVxuICB9XSk7XG5cbiAgcmV0dXJuIFV0aWxzO1xufSgpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHRyYWNrLiAgQ29udGFpbnMgbWV0aG9kcyBmb3IgcGFyc2luZyBldmVudHMgYW5kIGtlZXBpbmcgdHJhY2sgb2YgcG9pbnRlci5cbiAqL1xuXG52YXIgVHJhY2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFjayhpbmRleCwgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFjayk7XG5cbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZXZlbnRJbmRleCA9IDA7XG4gICAgdGhpcy5wb2ludGVyID0gMDtcbiAgICB0aGlzLmxhc3RUaWNrID0gMDtcbiAgICB0aGlzLmxhc3RTdGF0dXMgPSBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgIHRoaXMucnVubmluZ0RlbHRhID0gMDtcbiAgICB0aGlzLmV2ZW50cyA9IFtdOyAvLyBFbnN1cmUgbGFzdCAzIGJ5dGVzIG9mIHRyYWNrIGFyZSBFbmQgb2YgVHJhY2sgZXZlbnRcblxuICAgIHZhciBsYXN0VGhyZWVCeXRlcyA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmRhdGEubGVuZ3RoIC0gMywgdGhpcy5kYXRhLmxlbmd0aCk7XG5cbiAgICBpZiAoIShsYXN0VGhyZWVCeXRlc1swXSA9PT0gMHhmZiAmJiBsYXN0VGhyZWVCeXRlc1sxXSA9PT0gMHgyZiAmJiBsYXN0VGhyZWVCeXRlc1syXSA9PT0gMHgwMCkpIHtcbiAgICAgIHRocm93ICdJbnZhbGlkIE1JREkgZmlsZTsgTGFzdCB0aHJlZSBieXRlcyBvZiB0cmFjayAnICsgdGhpcy5pbmRleCArICdtdXN0IGJlIEZGIDJGIDAwIHRvIG1hcmsgZW5kIG9mIHRyYWNrJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyBhbGwgc3RhdGVmdWwgdHJhY2sgaW5mb3JtYWlvbiB1c2VkIGR1cmluZyBwbGF5YmFjay5cbiAgICogQHJldHVybiB7VHJhY2t9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFRyYWNrLCBbe1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmV2ZW50SW5kZXggPSAwO1xuICAgICAgdGhpcy5wb2ludGVyID0gMDtcbiAgICAgIHRoaXMubGFzdFRpY2sgPSAwO1xuICAgICAgdGhpcy5sYXN0U3RhdHVzID0gbnVsbDtcbiAgICAgIHRoaXMuZGVsdGEgPSAwO1xuICAgICAgdGhpcy5ydW5uaW5nRGVsdGEgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0cmFjayB0byBiZSBlbmFibGVkIGR1cmluZyBwbGF5YmFjay5cbiAgICAgKiBAcmV0dXJuIHtUcmFja31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhpcyB0cmFjayB0byBiZSBkaXNhYmxlZCBkdXJpbmcgcGxheWJhY2suXG4gICAgICogQHJldHVybiB7VHJhY2t9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0cmFjayBldmVudCBpbmRleCB0byB0aGUgbmVhcmVzdCBldmVudCB0byB0aGUgZ2l2ZW4gdGljay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGlja1xuICAgICAqIEByZXR1cm4ge1RyYWNrfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RXZlbnRJbmRleEJ5VGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRFdmVudEluZGV4QnlUaWNrKHRpY2spIHtcbiAgICAgIHRpY2sgPSB0aWNrIHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2ldLnRpY2sgPj0gdGljaykge1xuICAgICAgICAgIHRoaXMuZXZlbnRJbmRleCA9IGk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBieXRlIGxvY2F0ZWQgYXQgcG9pbnRlciBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50Qnl0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXJyZW50Qnl0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjb3VudCBvZiBkZWx0YSBieXRlcyBhbmQgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldERlbHRhQnl0ZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlbHRhQnl0ZUNvdW50KCkge1xuICAgICAgcmV0dXJuIFV0aWxzLmdldFZhckludExlbmd0aCh0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5wb2ludGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkZWx0YSB2YWx1ZSBhdCBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVsdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVsdGEoKSB7XG4gICAgICByZXR1cm4gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5wb2ludGVyLCB0aGlzLnBvaW50ZXIgKyB0aGlzLmdldERlbHRhQnl0ZUNvdW50KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBldmVudCB3aXRoaW4gYSBnaXZlbiB0cmFjayBzdGFydGluZyBhdCBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpY2tcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRyeVJ1biAtIElmIHRydWUgZXZlbnRzIHdpbGwgYmUgcGFyc2VkIGFuZCByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRpbWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVFdmVudChjdXJyZW50VGljaywgZHJ5UnVuKSB7XG4gICAgICBkcnlSdW4gPSBkcnlSdW4gfHwgZmFsc2U7XG5cbiAgICAgIGlmIChkcnlSdW4pIHtcbiAgICAgICAgdmFyIGVsYXBzZWRUaWNrcyA9IGN1cnJlbnRUaWNrIC0gdGhpcy5sYXN0VGljaztcbiAgICAgICAgdmFyIGRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICAgICAgICB2YXIgZXZlbnRSZWFkeSA9IGVsYXBzZWRUaWNrcyA+PSBkZWx0YTtcblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyIDwgdGhpcy5kYXRhLmxlbmd0aCAmJiAoZHJ5UnVuIHx8IGV2ZW50UmVhZHkpKSB7XG4gICAgICAgICAgdmFyIF9ldmVudCA9IHRoaXMucGFyc2VFdmVudCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkgcmV0dXJuIF9ldmVudDsgLy8gUmVjdXJzaXZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGZvciBlYWNoIGV2ZW50IGFoZWFkIHRoYXQgaGFzIDAgZGVsdGEgdGltZT9cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGV0J3MgYWN0dWFsbHkgcGxheSB0aGUgTUlESSBmcm9tIHRoZSBnZW5lcmF0ZWQgSlNPTiBldmVudHMgY3JlYXRlZCBieSB0aGUgZHJ5IHJ1bi5cbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRJbmRleF0gJiYgdGhpcy5ldmVudHNbdGhpcy5ldmVudEluZGV4XS50aWNrIDw9IGN1cnJlbnRUaWNrKSB7XG4gICAgICAgICAgdGhpcy5ldmVudEluZGV4Kys7XG4gICAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkgcmV0dXJuIHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRJbmRleCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3RyaW5nIGRhdGEgZnJvbSBldmVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnRTdGFydEluZGV4XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RyaW5nRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCkge1xuICAgICAgdmFyIHZhckludExlbmd0aCA9IFV0aWxzLmdldFZhckludExlbmd0aCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMikpO1xuICAgICAgdmFyIHZhckludFZhbHVlID0gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMiwgZXZlbnRTdGFydEluZGV4ICsgMiArIHZhckludExlbmd0aCkpO1xuICAgICAgdmFyIGxldHRlcnMgPSBVdGlscy5ieXRlc1RvTGV0dGVycyh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMiArIHZhckludExlbmd0aCwgZXZlbnRTdGFydEluZGV4ICsgMiArIHZhckludExlbmd0aCArIHZhckludFZhbHVlKSk7XG4gICAgICByZXR1cm4gbGV0dGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGV2ZW50IGludG8gSlNPTiBhbmQgYWR2YW5jZXMgcG9pbnRlciBmb3IgdGhlIHRyYWNrXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUV2ZW50KCkge1xuICAgICAgdmFyIGV2ZW50U3RhcnRJbmRleCA9IHRoaXMucG9pbnRlciArIHRoaXMuZ2V0RGVsdGFCeXRlQ291bnQoKTtcbiAgICAgIHZhciBldmVudEpzb24gPSB7fTtcbiAgICAgIHZhciBkZWx0YUJ5dGVDb3VudCA9IHRoaXMuZ2V0RGVsdGFCeXRlQ291bnQoKTtcbiAgICAgIGV2ZW50SnNvbi50cmFjayA9IHRoaXMuaW5kZXggKyAxO1xuICAgICAgZXZlbnRKc29uLmRlbHRhID0gdGhpcy5nZXREZWx0YSgpO1xuICAgICAgdGhpcy5sYXN0VGljayA9IHRoaXMubGFzdFRpY2sgKyBldmVudEpzb24uZGVsdGE7XG4gICAgICB0aGlzLnJ1bm5pbmdEZWx0YSArPSBldmVudEpzb24uZGVsdGE7XG4gICAgICBldmVudEpzb24udGljayA9IHRoaXMucnVubmluZ0RlbHRhO1xuICAgICAgZXZlbnRKc29uLmJ5dGVJbmRleCA9IHRoaXMucG9pbnRlcjsgLy9ldmVudEpzb24ucmF3ID0gZXZlbnQ7XG5cbiAgICAgIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA9PSAweGZmKSB7XG4gICAgICAgIC8vIE1ldGEgRXZlbnRcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG1ldGEgZXZlbnQgd2Ugc2hvdWxkIGVtaXQgdGhlIGRhdGEgYW5kIGltbWVkaWF0ZWx5IG1vdmUgdG8gdGhlIG5leHQgZXZlbnRcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIHdlIGxldCBpdCBydW4gdGhyb3VnaCB0aGUgbmV4dCBjeWNsZSBhIHNsaWdodCBkZWxheSB3aWxsIGFjY3VtdWxhdGUgaWYgbXVsdGlwbGUgdHJhY2tzXG4gICAgICAgIC8vIGFyZSBiZWluZyBwbGF5ZWQgc2ltdWx0YW5lb3VzbHlcbiAgICAgICAgc3dpdGNoICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV0pIHtcbiAgICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICAvLyBTZXF1ZW5jZSBOdW1iZXJcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ1NlcXVlbmNlIE51bWJlcic7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHgwMTpcbiAgICAgICAgICAgIC8vIFRleHQgRXZlbnRcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ1RleHQgRXZlbnQnO1xuICAgICAgICAgICAgZXZlbnRKc29uLnN0cmluZyA9IHRoaXMuZ2V0U3RyaW5nRGF0YShldmVudFN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgICAgICAvLyBDb3B5cmlnaHQgTm90aWNlXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdDb3B5cmlnaHQgTm90aWNlJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweDAzOlxuICAgICAgICAgICAgLy8gU2VxdWVuY2UvVHJhY2sgTmFtZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnU2VxdWVuY2UvVHJhY2sgTmFtZSc7XG4gICAgICAgICAgICBldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHgwNDpcbiAgICAgICAgICAgIC8vIEluc3RydW1lbnQgTmFtZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnSW5zdHJ1bWVudCBOYW1lJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5zdHJpbmcgPSB0aGlzLmdldFN0cmluZ0RhdGEoZXZlbnRTdGFydEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweDA1OlxuICAgICAgICAgICAgLy8gTHlyaWNcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ0x5cmljJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5zdHJpbmcgPSB0aGlzLmdldFN0cmluZ0RhdGEoZXZlbnRTdGFydEluZGV4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweDA2OlxuICAgICAgICAgICAgLy8gTWFya2VyXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdNYXJrZXInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4MDc6XG4gICAgICAgICAgICAvLyBDdWUgUG9pbnRcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ0N1ZSBQb2ludCc7XG4gICAgICAgICAgICBldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHgwOTpcbiAgICAgICAgICAgIC8vIERldmljZSBOYW1lXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdEZXZpY2UgTmFtZSc7XG4gICAgICAgICAgICBldmVudEpzb24uc3RyaW5nID0gdGhpcy5nZXRTdHJpbmdEYXRhKGV2ZW50U3RhcnRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICAgIC8vIE1JREkgQ2hhbm5lbCBQcmVmaXhcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ01JREkgQ2hhbm5lbCBQcmVmaXgnO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4MjE6XG4gICAgICAgICAgICAvLyBNSURJIFBvcnRcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ01JREkgUG9ydCc7XG4gICAgICAgICAgICBldmVudEpzb24uZGF0YSA9IFV0aWxzLmJ5dGVzVG9OdW1iZXIoW3RoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAzXV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4MkY6XG4gICAgICAgICAgICAvLyBFbmQgb2YgVHJhY2tcbiAgICAgICAgICAgIGV2ZW50SnNvbi5uYW1lID0gJ0VuZCBvZiBUcmFjayc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHg1MTpcbiAgICAgICAgICAgIC8vIFNldCBUZW1wb1xuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnU2V0IFRlbXBvJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5kYXRhID0gTWF0aC5yb3VuZCg2MDAwMDAwMCAvIFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDYpKSk7XG4gICAgICAgICAgICB0aGlzLnRlbXBvID0gZXZlbnRKc29uLmRhdGE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHg1NDpcbiAgICAgICAgICAgIC8vIFNNVFBFIE9mZnNldFxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnU01UUEUgT2Zmc2V0JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweDU4OlxuICAgICAgICAgICAgLy8gVGltZSBTaWduYXR1cmVcbiAgICAgICAgICAgIC8vIEZGIDU4IDA0IG5uIGRkIGNjIGJiXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdUaW1lIFNpZ25hdHVyZSc7XG4gICAgICAgICAgICBldmVudEpzb24uZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheShldmVudFN0YXJ0SW5kZXggKyAzLCBldmVudFN0YXJ0SW5kZXggKyA3KTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi50aW1lU2lnbmF0dXJlID0gXCJcIiArIGV2ZW50SnNvbi5kYXRhWzBdICsgXCIvXCIgKyBNYXRoLnBvdygyLCBldmVudEpzb24uZGF0YVsxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHg1OTpcbiAgICAgICAgICAgIC8vIEtleSBTaWduYXR1cmVcbiAgICAgICAgICAgIC8vIEZGIDU5IDAyIHNmIG1pXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdLZXkgU2lnbmF0dXJlJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5kYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDMsIGV2ZW50U3RhcnRJbmRleCArIDUpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnRKc29uLmRhdGFbMF0gPj0gMCkge1xuICAgICAgICAgICAgICBldmVudEpzb24ua2V5U2lnbmF0dXJlID0gQ29uc3RhbnRzLkNJUkNMRV9PRl9GSUZUSFNbZXZlbnRKc29uLmRhdGFbMF1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudEpzb24uZGF0YVswXSA8IDApIHtcbiAgICAgICAgICAgICAgZXZlbnRKc29uLmtleVNpZ25hdHVyZSA9IENvbnN0YW50cy5DSVJDTEVfT0ZfRk9VUlRIU1tNYXRoLmFicyhldmVudEpzb24uZGF0YVswXSldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXZlbnRKc29uLmRhdGFbMV0gPT0gMCkge1xuICAgICAgICAgICAgICBldmVudEpzb24ua2V5U2lnbmF0dXJlICs9IFwiIE1ham9yXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50SnNvbi5kYXRhWzFdID09IDEpIHtcbiAgICAgICAgICAgICAgZXZlbnRKc29uLmtleVNpZ25hdHVyZSArPSBcIiBNaW5vclwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHg3RjpcbiAgICAgICAgICAgIC8vIFNlcXVlbmNlci1TcGVjaWZpYyBNZXRhLWV2ZW50XG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdTZXF1ZW5jZXItU3BlY2lmaWMgTWV0YS1ldmVudCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdVbmtub3duOiAnICsgdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhckludExlbmd0aCA9IFV0aWxzLmdldFZhckludExlbmd0aCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMikpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMiwgZXZlbnRTdGFydEluZGV4ICsgMiArIHZhckludExlbmd0aCkpOyAvL2NvbnNvbGUubG9nKGV2ZW50SnNvbik7XG5cbiAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMyArIGxlbmd0aDsgLy9jb25zb2xlLmxvZyhldmVudEpzb24pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA9PT0gMHhmMCkge1xuICAgICAgICAvLyBTeXNleFxuICAgICAgICBldmVudEpzb24ubmFtZSA9ICdTeXNleCc7XG4gICAgICAgIHZhciB2YXJRdWFudGl0eUJ5dGVMZW5ndGggPSBVdGlscy5nZXRWYXJJbnRMZW5ndGgodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDEpKTtcbiAgICAgICAgdmFyIHZhclF1YW50aXR5Qnl0ZVZhbHVlID0gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMSwgZXZlbnRTdGFydEluZGV4ICsgMSArIHZhclF1YW50aXR5Qnl0ZUxlbmd0aCkpO1xuICAgICAgICBldmVudEpzb24uZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheShldmVudFN0YXJ0SW5kZXggKyAxICsgdmFyUXVhbnRpdHlCeXRlTGVuZ3RoLCBldmVudFN0YXJ0SW5kZXggKyAxICsgdmFyUXVhbnRpdHlCeXRlTGVuZ3RoICsgdmFyUXVhbnRpdHlCeXRlVmFsdWUpO1xuICAgICAgICB0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAxICsgdmFyUXVhbnRpdHlCeXRlTGVuZ3RoICsgdmFyUXVhbnRpdHlCeXRlVmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdID09PSAweGY3KSB7XG4gICAgICAgIC8vIFN5c2V4IChlc2NhcGUpXG4gICAgICAgIC8vIGh0dHA6Ly93d3cuc29tYXNjYXBlLm9yZy9taWRpL3RlY2gvbWZpbGUuaHRtbCNzeXNleFxuICAgICAgICBldmVudEpzb24ubmFtZSA9ICdTeXNleCAoZXNjYXBlKSc7XG5cbiAgICAgICAgdmFyIF92YXJRdWFudGl0eUJ5dGVMZW5ndGggPSBVdGlscy5nZXRWYXJJbnRMZW5ndGgodGhpcy5kYXRhLnN1YmFycmF5KGV2ZW50U3RhcnRJbmRleCArIDEpKTtcblxuICAgICAgICB2YXIgX3ZhclF1YW50aXR5Qnl0ZVZhbHVlID0gVXRpbHMucmVhZFZhckludCh0aGlzLmRhdGEuc3ViYXJyYXkoZXZlbnRTdGFydEluZGV4ICsgMSwgZXZlbnRTdGFydEluZGV4ICsgMSArIF92YXJRdWFudGl0eUJ5dGVMZW5ndGgpKTtcblxuICAgICAgICBldmVudEpzb24uZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheShldmVudFN0YXJ0SW5kZXggKyAxICsgX3ZhclF1YW50aXR5Qnl0ZUxlbmd0aCwgZXZlbnRTdGFydEluZGV4ICsgMSArIF92YXJRdWFudGl0eUJ5dGVMZW5ndGggKyBfdmFyUXVhbnRpdHlCeXRlVmFsdWUpO1xuICAgICAgICB0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAxICsgX3ZhclF1YW50aXR5Qnl0ZUxlbmd0aCArIF92YXJRdWFudGl0eUJ5dGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFZvaWNlIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA8IDB4ODApIHtcbiAgICAgICAgICAvLyBSdW5uaW5nIHN0YXR1c1xuICAgICAgICAgIGV2ZW50SnNvbi5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICBldmVudEpzb24ubm90ZU51bWJlciA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdO1xuICAgICAgICAgIGV2ZW50SnNvbi5ub3RlTmFtZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XV07XG4gICAgICAgICAgZXZlbnRKc29uLnZlbG9jaXR5ID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuXG4gICAgICAgICAgaWYgKHRoaXMubGFzdFN0YXR1cyA8PSAweDhmKSB7XG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdOb3RlIG9mZic7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ODAgKyAxO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdFN0YXR1cyA8PSAweDlmKSB7XG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdOb3RlIG9uJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHg5MCArIDE7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0U3RhdHVzIDw9IDB4YWYpIHtcbiAgICAgICAgICAgIC8vIFBvbHlwaG9uaWMgS2V5IFByZXNzdXJlXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdQb2x5cGhvbmljIEtleSBQcmVzc3VyZSc7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YTAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLm5vdGUgPSBDb25zdGFudHMuTk9URVNbdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdXTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi5wcmVzc3VyZSA9IGV2ZW50WzFdO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdFN0YXR1cyA8PSAweGJmKSB7XG4gICAgICAgICAgICAvLyBDb250cm9sbGVyIENoYW5nZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnQ29udHJvbGxlciBDaGFuZ2UnO1xuICAgICAgICAgICAgZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGIwICsgMTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi5udW1iZXIgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV07XG4gICAgICAgICAgICBldmVudEpzb24udmFsdWUgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMl07XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0U3RhdHVzIDw9IDB4Y2YpIHtcbiAgICAgICAgICAgIC8vIFByb2dyYW0gQ2hhbmdlXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdQcm9ncmFtIENoYW5nZSc7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YzAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLnZhbHVlID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdFN0YXR1cyA8PSAweGRmKSB7XG4gICAgICAgICAgICAvLyBDaGFubmVsIEtleSBQcmVzc3VyZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnQ2hhbm5lbCBLZXkgUHJlc3N1cmUnO1xuICAgICAgICAgICAgZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGQwICsgMTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDE7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RTdGF0dXMgPD0gMHhlZikge1xuICAgICAgICAgICAgLy8gUGl0Y2ggQmVuZFxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnUGl0Y2ggQmVuZCc7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ZTAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLnZhbHVlID0gdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDJdO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgXCJVbmtub3duIGV2ZW50IChydW5uaW5nKTogXCIuY29uY2F0KHRoaXMubGFzdFN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdFN0YXR1cyA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4OGYpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgb2ZmXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdOb3RlIG9mZic7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4ODAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLm5vdGVOdW1iZXIgPSB0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV07XG4gICAgICAgICAgICBldmVudEpzb24ubm90ZU5hbWUgPSBDb25zdGFudHMuTk9URVNbdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdXTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi52ZWxvY2l0eSA9IE1hdGgucm91bmQodGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDJdIC8gMTI3ICogMTAwKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDM7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA8PSAweDlmKSB7XG4gICAgICAgICAgICAvLyBOb3RlIG9uXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdOb3RlIG9uJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHg5MCArIDE7XG4gICAgICAgICAgICBldmVudEpzb24ubm90ZU51bWJlciA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi5ub3RlTmFtZSA9IENvbnN0YW50cy5OT1RFU1t0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMV1dO1xuICAgICAgICAgICAgZXZlbnRKc29uLnZlbG9jaXR5ID0gTWF0aC5yb3VuZCh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4ICsgMl0gLyAxMjcgKiAxMDApO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4YWYpIHtcbiAgICAgICAgICAgIC8vIFBvbHlwaG9uaWMgS2V5IFByZXNzdXJlXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdQb2x5cGhvbmljIEtleSBQcmVzc3VyZSc7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YTAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLm5vdGUgPSBDb25zdGFudHMuTk9URVNbdGhpcy5kYXRhW2V2ZW50U3RhcnRJbmRleCArIDFdXTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi5wcmVzc3VyZSA9IGV2ZW50WzJdO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyICs9IGRlbHRhQnl0ZUNvdW50ICsgMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXhdIDw9IDB4YmYpIHtcbiAgICAgICAgICAgIC8vIENvbnRyb2xsZXIgQ2hhbmdlXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdDb250cm9sbGVyIENoYW5nZSc7XG4gICAgICAgICAgICBldmVudEpzb24uY2hhbm5lbCA9IHRoaXMubGFzdFN0YXR1cyAtIDB4YjAgKyAxO1xuICAgICAgICAgICAgZXZlbnRKc29uLm51bWJlciA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi52YWx1ZSA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAyXTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDM7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA8PSAweGNmKSB7XG4gICAgICAgICAgICAvLyBQcm9ncmFtIENoYW5nZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnUHJvZ3JhbSBDaGFuZ2UnO1xuICAgICAgICAgICAgZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGMwICsgMTtcbiAgICAgICAgICAgIGV2ZW50SnNvbi52YWx1ZSA9IHRoaXMuZGF0YVtldmVudFN0YXJ0SW5kZXggKyAxXTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA8PSAweGRmKSB7XG4gICAgICAgICAgICAvLyBDaGFubmVsIEtleSBQcmVzc3VyZVxuICAgICAgICAgICAgZXZlbnRKc29uLm5hbWUgPSAnQ2hhbm5lbCBLZXkgUHJlc3N1cmUnO1xuICAgICAgICAgICAgZXZlbnRKc29uLmNoYW5uZWwgPSB0aGlzLmxhc3RTdGF0dXMgLSAweGQwICsgMTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlciArPSBkZWx0YUJ5dGVDb3VudCArIDI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSA8PSAweGVmKSB7XG4gICAgICAgICAgICAvLyBQaXRjaCBCZW5kXG4gICAgICAgICAgICBldmVudEpzb24ubmFtZSA9ICdQaXRjaCBCZW5kJztcbiAgICAgICAgICAgIGV2ZW50SnNvbi5jaGFubmVsID0gdGhpcy5sYXN0U3RhdHVzIC0gMHhlMCArIDE7XG4gICAgICAgICAgICB0aGlzLnBvaW50ZXIgKz0gZGVsdGFCeXRlQ291bnQgKyAzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBcIlVua25vd24gZXZlbnQ6IFwiLmNvbmNhdCh0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XSk7IC8vZXZlbnRKc29uLm5hbWUgPSBgVW5rbm93bi4gIFBvaW50ZXI6ICR7dGhpcy5wb2ludGVyLnRvU3RyaW5nKCl9LCAke2V2ZW50U3RhcnRJbmRleC50b1N0cmluZygpfSwgJHt0aGlzLmRhdGFbZXZlbnRTdGFydEluZGV4XX0sICR7dGhpcy5kYXRhLmxlbmd0aH1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRlbHRhICs9IGV2ZW50SnNvbi5kZWx0YTtcbiAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXZlbnRKc29uKTtcbiAgICAgIHJldHVybiBldmVudEpzb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBwb2ludGVyIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHRyYWNrLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuZE9mVHJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZUcmFjaygpIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMV0gPT0gMHhmZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgMl0gPT0gMHgyZiAmJiB0aGlzLmRhdGFbdGhpcy5wb2ludGVyICsgM10gPT0gMHgwMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFjaztcbn0oKTtcblxuaWYgKCFVaW50OEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVaW50OEFycmF5LnByb3RvdHlwZSwgJ2ZvckVhY2gnLCB7XG4gICAgdmFsdWU6IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoXG4gIH0pO1xufVxuLyoqXG4gKiBNYWluIHBsYXllciBjbGFzcy4gIENvbnRhaW5zIG1ldGhvZHMgdG8gbG9hZCBmaWxlcywgc3RhcnQsIHN0b3AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAtIENhbGxiYWNrIHRvIGZpcmUgZm9yIGVhY2ggTUlESSBldmVudC4gIENhbiBhbHNvIGJlIGFkZGVkIHdpdGggb24oJ21pZGlFdmVudCcsIGZuKVxuICogQHBhcmFtIHthcnJheX0gLSBBcnJheSBidWZmZXIgb2YgTUlESSBmaWxlIChvcHRpb25hbCkuXG4gKi9cblxuXG52YXIgUGxheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxheWVyKGV2ZW50SGFuZGxlciwgYnVmZmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XG5cbiAgICB0aGlzLnNhbXBsZVJhdGUgPSA1OyAvLyBtaWxsaXNlY29uZHNcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBudWxsO1xuICAgIHRoaXMubWlkaUNodW5rc0J5dGVMZW5ndGggPSBudWxsO1xuICAgIHRoaXMuZGl2aXNpb247XG4gICAgdGhpcy5mb3JtYXQ7XG4gICAgdGhpcy5zZXRJbnRlcnZhbElkID0gZmFsc2U7XG4gICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICB0aGlzLmluc3RydW1lbnRzID0gW107XG4gICAgdGhpcy5kZWZhdWx0VGVtcG8gPSAxMjA7XG4gICAgdGhpcy50ZW1wbyA9IG51bGw7XG4gICAgdGhpcy5zdGFydFRpY2sgPSAwO1xuICAgIHRoaXMudGljayA9IDA7XG4gICAgdGhpcy5sYXN0VGljayA9IG51bGw7XG4gICAgdGhpcy5pbkxvb3AgPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsVGlja3MgPSAwO1xuICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgdGhpcy50b3RhbEV2ZW50cyA9IDA7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZXZlbnRIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB0aGlzLm9uKCdtaWRpRXZlbnQnLCBldmVudEhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBMb2FkIGEgZmlsZSBpbnRvIHRoZSBwbGF5ZXIgKE5vZGUuanMgb25seSkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gUGF0aCBvZiBmaWxlLlxuICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBsYXllciwgW3tcbiAgICBrZXk6IFwibG9hZEZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEZpbGUocGF0aCkge1xuICAgICAge1xuICAgICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlTG9hZGVkKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgYW4gYXJyYXkgYnVmZmVyIGludG8gdGhlIHBsYXllci5cbiAgICAgKiBAcGFyYW0ge2FycmF5fSBhcnJheUJ1ZmZlciAtIEFycmF5IGJ1ZmZlciBvZiBmaWxlIHRvIGJlIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkQXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZEFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVMb2FkZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBhIGRhdGEgVVJJIGludG8gdGhlIHBsYXllci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIERhdGEgVVJJIHRvIGJlIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2FkRGF0YVVyaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkRGF0YVVyaShkYXRhVXJpKSB7XG4gICAgICAvLyBjb252ZXJ0IGJhc2U2NCB0byByYXcgYmluYXJ5IGRhdGEgaGVsZCBpbiBhIHN0cmluZy5cbiAgICAgIC8vIGRvZXNuJ3QgaGFuZGxlIFVSTEVuY29kZWQgRGF0YVVSSXMgLSBzZWUgU08gYW5zd2VyICM2ODUwMjc2IGZvciBjb2RlIHRoYXQgZG9lcyB0aGlzXG4gICAgICB2YXIgYnl0ZVN0cmluZyA9IFV0aWxzLmF0b2IoZGF0YVVyaS5zcGxpdCgnLCcpWzFdKTsgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYW4gQXJyYXlCdWZmZXJcblxuICAgICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVmZmVyID0gaWE7XG4gICAgICByZXR1cm4gdGhpcy5maWxlTG9hZGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlc2l6ZSBvZiBsb2FkZWQgZmlsZSBpbiBudW1iZXIgb2YgYnl0ZXMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBmaWxlc2l6ZS5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIubGVuZ3RoIDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBkZWZhdWx0IHRlbXBvLCBwYXJzZXMgZmlsZSBmb3IgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLCBhbmQgZG9lcyBhIGRyeSBydW4gdG8gY2FsY3VsYXRlIHRvdGFsIGxlbmd0aC5cbiAgICAgKiBQb3B1bGF0ZXMgdGhpcy5ldmVudHMgJiB0aGlzLnRvdGFsVGlja3MuXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsZUxvYWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxlTG9hZGVkKCkge1xuICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlKCkpIHRocm93ICdJbnZhbGlkIE1JREkgZmlsZTsgc2hvdWxkIHN0YXJ0IHdpdGggTVRoZCc7XG4gICAgICByZXR1cm4gdGhpcy5zZXRUZW1wbyh0aGlzLmRlZmF1bHRUZW1wbykuZ2V0RGl2aXNpb24oKS5nZXRGb3JtYXQoKS5nZXRUcmFja3MoKS5kcnlSdW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGZpbGUgdXNpbmcgc2ltcGxlIG1lYW5zIC0gZmlyc3QgZm91ciBieXRlcyBzaG91bGQgPT0gTVRoZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCAxNSkpKTtcbiAgICAgIHJldHVybiBVdGlscy5ieXRlc1RvTGV0dGVycyh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCA0KSkgPT09ICdNVGhkJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBNSURJIGZpbGUgZm9ybWF0IGZvciBsb2FkZWQgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KCkge1xuICAgICAgLypcbiAgICAgIE1JREkgZmlsZXMgY29tZSBpbiAzIHZhcmlhdGlvbnM6XG4gICAgICBGb3JtYXQgMCB3aGljaCBjb250YWluIGEgc2luZ2xlIHRyYWNrXG4gICAgICBGb3JtYXQgMSB3aGljaCBjb250YWluIG9uZSBvciBtb3JlIHNpbXVsdGFuZW91cyB0cmFja3NcbiAgICAgIChpZSBhbGwgdHJhY2tzIGFyZSB0byBiZSBwbGF5ZWQgc2ltdWx0YW5lb3VzbHkpLlxuICAgICAgRm9ybWF0IDIgd2hpY2ggY29udGFpbiBvbmUgb3IgbW9yZSBpbmRlcGVuZGFudCB0cmFja3NcbiAgICAgIChpZSBlYWNoIHRyYWNrIGlzIHRvIGJlIHBsYXllZCBpbmRlcGVuZGFudGx5IG9mIHRoZSBvdGhlcnMpLlxuICAgICAgcmV0dXJuIFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKTtcbiAgICAgICovXG4gICAgICB0aGlzLmZvcm1hdCA9IFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgb3V0IHRyYWNrcywgcGxhY2VzIHRoZW0gaW4gdGhpcy50cmFja3MgYW5kIGluaXRpYWxpemVzIHRoaXMucG9pbnRlcnNcbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhY2tzKCkge1xuICAgICAgdGhpcy50cmFja3MgPSBbXTtcbiAgICAgIHZhciB0cmFja09mZnNldCA9IDA7XG5cbiAgICAgIHdoaWxlICh0cmFja09mZnNldCA8IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoVXRpbHMuYnl0ZXNUb0xldHRlcnModGhpcy5idWZmZXIuc3ViYXJyYXkodHJhY2tPZmZzZXQsIHRyYWNrT2Zmc2V0ICsgNCkpID09ICdNVHJrJykge1xuICAgICAgICAgIHZhciB0cmFja0xlbmd0aCA9IFV0aWxzLmJ5dGVzVG9OdW1iZXIodGhpcy5idWZmZXIuc3ViYXJyYXkodHJhY2tPZmZzZXQgKyA0LCB0cmFja09mZnNldCArIDgpKTtcbiAgICAgICAgICB0aGlzLnRyYWNrcy5wdXNoKG5ldyBUcmFjayh0aGlzLnRyYWNrcy5sZW5ndGgsIHRoaXMuYnVmZmVyLnN1YmFycmF5KHRyYWNrT2Zmc2V0ICsgOCwgdHJhY2tPZmZzZXQgKyA4ICsgdHJhY2tMZW5ndGgpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFja09mZnNldCArPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRyYWNrT2Zmc2V0ICsgNCwgdHJhY2tPZmZzZXQgKyA4KSkgKyA4O1xuICAgICAgfSAvLyBHZXQgc3VtIG9mIGFsbCBNSURJIGNodW5rcyBoZXJlIHdoaWxlIHdlJ3JlIGF0IGl0XG5cblxuICAgICAgdmFyIHRyYWNrQ2h1bmtzQnl0ZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFja0NodW5rc0J5dGVMZW5ndGggKz0gOCArIHRyYWNrLmRhdGEubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1pZGlDaHVua3NCeXRlTGVuZ3RoID0gQ29uc3RhbnRzLkhFQURFUl9DSFVOS19MRU5HVEggKyB0cmFja0NodW5rc0J5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBhIHRyYWNrIGZvciBwbGF5aW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFja051bWJlciAtIFRyYWNrIG51bWJlclxuICAgICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZVRyYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVRyYWNrKHRyYWNrTnVtYmVyKSB7XG4gICAgICB0aGlzLnRyYWNrc1t0cmFja051bWJlciAtIDFdLmVuYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGEgdHJhY2sgZm9yIHBsYXlpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IC0gVHJhY2sgbnVtYmVyXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVRyYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVUcmFjayh0cmFja051bWJlcikge1xuICAgICAgdGhpcy50cmFja3NbdHJhY2tOdW1iZXIgLSAxXS5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBxdWFydGVyIG5vdGUgZGl2aXNpb24gb2YgbG9hZGVkIE1JREkgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXREaXZpc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaXZpc2lvbigpIHtcbiAgICAgIHRoaXMuZGl2aXNpb24gPSBVdGlscy5ieXRlc1RvTnVtYmVyKHRoaXMuYnVmZmVyLnN1YmFycmF5KDEyLCBDb25zdGFudHMuSEVBREVSX0NIVU5LX0xFTkdUSCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtYWluIHBsYXkgbG9vcC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IC0gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYmVpbmcgY2FsbGVkIHNpbXBseSBmb3IgcGFyc2luZyBwdXJwb3Nlcy4gIERpc3JlZ2FyZHMgdGltaW5nIGlmIHNvLlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBsYXlMb29wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXlMb29wKGRyeVJ1bikge1xuICAgICAgaWYgKCF0aGlzLmluTG9vcCkge1xuICAgICAgICB0aGlzLmluTG9vcCA9IHRydWU7XG4gICAgICAgIHRoaXMudGljayA9IHRoaXMuZ2V0Q3VycmVudFRpY2soKTtcbiAgICAgICAgdGhpcy50cmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2ssIGluZGV4KSB7XG4gICAgICAgICAgLy8gSGFuZGxlIG5leHQgZXZlbnRcbiAgICAgICAgICBpZiAoIWRyeVJ1biAmJiB0aGlzLmVuZE9mRmlsZSgpKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdlbmQgb2YgZmlsZScpXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJQbGF5ZXJFdmVudCgnZW5kT2ZGaWxlJyk7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gdHJhY2suaGFuZGxlRXZlbnQodGhpcy50aWNrLCBkcnlSdW4pO1xuXG4gICAgICAgICAgICBpZiAoZHJ5UnVuICYmIGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmIChldmVudC5oYXNPd25Qcm9wZXJ0eSgnbmFtZScpICYmIGV2ZW50Lm5hbWUgPT09ICdTZXQgVGVtcG8nKSB7XG4gICAgICAgICAgICAgICAgLy8gR3JhYiB0ZW1wbyBpZiBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VGVtcG8gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGVtcG8oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXZlbnQuaGFzT3duUHJvcGVydHkoJ25hbWUnKSAmJiBldmVudC5uYW1lID09PSAnUHJvZ3JhbSBDaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RydW1lbnRzLmluY2x1ZGVzKGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0cnVtZW50cy5wdXNoKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc093blByb3BlcnR5KCduYW1lJykgJiYgZXZlbnQubmFtZSA9PT0gJ1NldCBUZW1wbycpIHtcbiAgICAgICAgICAgICAgICAvLyBHcmFiIHRlbXBvIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRlbXBvKGV2ZW50LmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGlmICghZHJ5UnVuKSB0aGlzLnRyaWdnZXJQbGF5ZXJFdmVudCgncGxheWluZycsIHtcbiAgICAgICAgICB0aWNrOiB0aGlzLnRpY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5Mb29wID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHRlciBmb3IgdGVtcG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IC0gVGVtcG8gaW4gYnBtIChkZWZhdWx0cyB0byAxMjApXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRUZW1wb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZW1wbyh0ZW1wbykge1xuICAgICAgdGhpcy50ZW1wbyA9IHRlbXBvO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHRlciBmb3Igc3RhcnRUaW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAtIFVUQyB0aW1lc3RhbXBcbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGFydFRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RhcnRUaW1lKHN0YXJ0VGltZSkge1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgcGxheWluZyBsb2FkZWQgTUlESSBmaWxlIGlmIG5vdCBhbHJlYWR5IHBsYXlpbmcuXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkpIHRocm93ICdBbHJlYWR5IHBsYXlpbmcuLi4nOyAvLyBJbml0aWFsaXplXG5cbiAgICAgIGlmICghdGhpcy5zdGFydFRpbWUpIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7IC8vIFN0YXJ0IHBsYXkgbG9vcFxuICAgICAgLy93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucGxheUxvb3AuYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRoaXMucGxheUxvb3AuYmluZCh0aGlzKSwgdGhpcy5zYW1wbGVSYXRlKTsgLy90aGlzLnNldEludGVydmFsSWQgPSB0aGlzLmxvb3AoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEbyBTb21ldGhpbmcgSGVyZVxuICAgICAgICB0aGlzLnBsYXlMb29wKCk7IC8vIFRoZW4gcmVjYWxsIHRoZSBwYXJlbnQgZnVuY3Rpb24gdG9cbiAgICAgICAgLy8gY3JlYXRlIGEgcmVjdXJzaXZlIGxvb3AuXG5cbiAgICAgICAgdGhpcy5sb29wKCk7XG4gICAgICB9LmJpbmQodGhpcyksIHRoaXMuc2FtcGxlUmF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdXNlcyBwbGF5YmFjayBpZiBwbGF5aW5nLlxuICAgICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInBhdXNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNldEludGVydmFsSWQpO1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbElkID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0VGljayA9IHRoaXMudGljaztcbiAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBwbGF5YmFjayBpZiBwbGF5aW5nLlxuICAgICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zZXRJbnRlcnZhbElkKTtcbiAgICAgIHRoaXMuc2V0SW50ZXJ2YWxJZCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydFRpY2sgPSAwO1xuICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgdGhpcy5yZXNldFRyYWNrcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNraXBzIHBsYXllciBwb2ludGVyIHRvIHNwZWNpZmllZCB0aWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAtIFRpY2sgdG8gc2tpcCB0by5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJza2lwVG9UaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBUb1RpY2sodGljaykge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLnN0YXJ0VGljayA9IHRpY2s7IC8vIE5lZWQgdG8gc2V0IHRyYWNrIGV2ZW50IGluZGV4ZXMgdG8gdGhlIG5lYXJlc3QgcG9zc2libGUgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCB0aWNrLlxuXG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICB0cmFjay5zZXRFdmVudEluZGV4QnlUaWNrKHRpY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2tpcHMgcGxheWVyIHBvaW50ZXIgdG8gc3BlY2lmaWVkIHBlcmNlbnRhZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IC0gUGVyY2VudCB2YWx1ZSBpbiBpbnRlZ2VyIGZvcm1hdC5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJza2lwVG9QZXJjZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNraXBUb1BlcmNlbnQocGVyY2VudCkge1xuICAgICAgaWYgKHBlcmNlbnQgPCAwIHx8IHBlcmNlbnQgPiAxMDApIHRocm93IFwiUGVyY2VudCBtdXN0IGJlIG51bWJlciBiZXR3ZWVuIDEgYW5kIDEwMC5cIjtcbiAgICAgIHRoaXMuc2tpcFRvVGljayhNYXRoLnJvdW5kKHBlcmNlbnQgLyAxMDAgKiB0aGlzLnRvdGFsVGlja3MpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTa2lwcyBwbGF5ZXIgcG9pbnRlciB0byBzcGVjaWZpZWQgc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gLSBTZWNvbmRzIHRvIHNraXAgdG8uXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2tpcFRvU2Vjb25kc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBza2lwVG9TZWNvbmRzKHNlY29uZHMpIHtcbiAgICAgIHZhciBzb25nVGltZSA9IHRoaXMuZ2V0U29uZ1RpbWUoKTtcbiAgICAgIGlmIChzZWNvbmRzIDwgMCB8fCBzZWNvbmRzID4gc29uZ1RpbWUpIHRocm93IHNlY29uZHMgKyBcIiBzZWNvbmRzIG5vdCB3aXRoaW4gc29uZyB0aW1lIG9mIFwiICsgc29uZ1RpbWU7XG4gICAgICB0aGlzLnNraXBUb1BlcmNlbnQoc2Vjb25kcyAvIHNvbmdUaW1lICogMTAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgcGxheWVyIGlzIHBsYXlpbmdcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQbGF5aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGxheWluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldEludGVydmFsSWQgPiAwIHx8IF90eXBlb2YodGhpcy5zZXRJbnRlcnZhbElkKSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBsb2FkZWQgTUlESSBmaWxlIHdpdGhvdXQgcmVnYXJkIGZvciB0aW1pbmcgYW5kIHNhdmVzIGV2ZW50cyBpbiB0aGlzLmV2ZW50cy4gIEVzc2VudGlhbGx5IHVzZWQgYXMgYSBwYXJzZXIuXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJ5UnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyeVJ1bigpIHtcbiAgICAgIC8vIFJlc2V0IHRyYWNrcyBmaXJzdFxuICAgICAgdGhpcy5yZXNldFRyYWNrcygpO1xuXG4gICAgICB3aGlsZSAoIXRoaXMuZW5kT2ZGaWxlKCkpIHtcbiAgICAgICAgdGhpcy5wbGF5TG9vcCh0cnVlKTsgLy9jb25zb2xlLmxvZyh0aGlzLmJ5dGVzUHJvY2Vzc2VkKCksIHRoaXMubWlkaUNodW5rc0J5dGVMZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZ2V0RXZlbnRzKCk7XG4gICAgICB0aGlzLnRvdGFsRXZlbnRzID0gdGhpcy5nZXRUb3RhbEV2ZW50cygpO1xuICAgICAgdGhpcy50b3RhbFRpY2tzID0gdGhpcy5nZXRUb3RhbFRpY2tzKCk7XG4gICAgICB0aGlzLnN0YXJ0VGljayA9IDA7XG4gICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7IC8vIExlYXZlIHRyYWNrcyBpbiBwcmlzdGluZSBjb25kaXNoXG5cbiAgICAgIHRoaXMucmVzZXRUcmFja3MoKTsgLy9jb25zb2xlLmxvZygnU29uZyB0aW1lOiAnICsgdGhpcy5nZXRTb25nVGltZSgpICsgJyBzZWNvbmRzIC8gJyArIHRoaXMudG90YWxUaWNrcyArICcgdGlja3MuJyk7XG5cbiAgICAgIHRoaXMudHJpZ2dlclBsYXllckV2ZW50KCdmaWxlTG9hZGVkJywgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHBsYXkgcG9pbnRlcnMgZm9yIGFsbCB0cmFja3MuXG4gICAgICogQHJldHVybiB7UGxheWVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRUcmFja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRUcmFja3MoKSB7XG4gICAgICB0aGlzLnRyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2sucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gYXJyYXkgb2YgZXZlbnRzIGdyb3VwZWQgYnkgdHJhY2suXG4gICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXZlbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzLm1hcChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrLmV2ZW50cztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRvdGFsIG51bWJlciBvZiB0aWNrcyBpbiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbFRpY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdGFsVGlja3MoKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy50cmFja3MubWFwKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICByZXR1cm4gdHJhY2suZGVsdGE7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdG90YWwgbnVtYmVyIG9mIGV2ZW50cyBpbiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUb3RhbEV2ZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIGxlbmd0aDogYS5ldmVudHMubGVuZ3RoICsgYi5ldmVudHMubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSwge1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBsZW5ndGg6IDBcbiAgICAgICAgfVxuICAgICAgfSkuZXZlbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBzb25nIGR1cmF0aW9uIGluIHNlY29uZHMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U29uZ1RpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U29uZ1RpbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbFRpY2tzIC8gdGhpcy5kaXZpc2lvbiAvIHRoaXMudGVtcG8gKiA2MDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyByZW1haW5pbmcgbnVtYmVyIG9mIHNlY29uZHMgaW4gcGxheWJhY2suXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U29uZ1RpbWVSZW1haW5pbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U29uZ1RpbWVSZW1haW5pbmcoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgodGhpcy50b3RhbFRpY2tzIC0gdGhpcy5nZXRDdXJyZW50VGljaygpKSAvIHRoaXMuZGl2aXNpb24gLyB0aGlzLnRlbXBvICogNjApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHJlbWFpbmluZyBwZXJjZW50IG9mIHBsYXliYWNrLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldFNvbmdQZXJjZW50UmVtYWluaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNvbmdQZXJjZW50UmVtYWluaW5nKCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5nZXRTb25nVGltZVJlbWFpbmluZygpIC8gdGhpcy5nZXRTb25nVGltZSgpICogMTAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGJ5dGVzIHByb2Nlc3NlZCBpbiB0aGUgbG9hZGVkIE1JREkgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJieXRlc1Byb2Nlc3NlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBieXRlc1Byb2Nlc3NlZCgpIHtcbiAgICAgIHJldHVybiBDb25zdGFudHMuSEVBREVSX0NIVU5LX0xFTkdUSCArIHRoaXMudHJhY2tzLmxlbmd0aCAqIDggKyB0aGlzLnRyYWNrcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludGVyOiBhLnBvaW50ZXIgKyBiLnBvaW50ZXJcbiAgICAgICAgfTtcbiAgICAgIH0sIHtcbiAgICAgICAgcG9pbnRlcjogMFxuICAgICAgfSkucG9pbnRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGV2ZW50cyBwbGF5ZWQgdXAgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJldmVudHNQbGF5ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRzUGxheWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV2ZW50SW5kZXg6IGEuZXZlbnRJbmRleCArIGIuZXZlbnRJbmRleFxuICAgICAgICB9O1xuICAgICAgfSwge1xuICAgICAgICBldmVudEluZGV4OiAwXG4gICAgICB9KS5ldmVudEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBwbGF5ZXIgcG9pbnRlciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBsb2FkZWQgTUlESSBmaWxlLlxuICAgICAqIFVzZWQgaW4gdHdvIHdheXM6XG4gICAgICogMS4gSWYgcGxheWluZyByZXN1bHQgaXMgYmFzZWQgb24gbG9hZGVkIEpTT04gZXZlbnRzLlxuICAgICAqIDIuIElmIHBhcnNpbmcgKGRyeVJ1bikgaXQncyBiYXNlZCBvbiB0aGUgYWN0dWFsIGJ1ZmZlciBsZW5ndGggdnMgYnl0ZXMgcHJvY2Vzc2VkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbmRPZkZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgICAgaWYgKHRoaXMuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaWNrcyAtIHRoaXMudGljayA8PSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ieXRlc1Byb2Nlc3NlZCgpID49IHRoaXMubWlkaUNodW5rc0J5dGVMZW5ndGg7IC8vdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRpY2sgbnVtYmVyIGluIHBsYXliYWNrLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldEN1cnJlbnRUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUaWNrKCkge1xuICAgICAgaWYgKCF0aGlzLnN0YXJ0VGltZSkgcmV0dXJuIHRoaXMuc3RhcnRUaWNrO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWUpIC8gMTAwMCAqICh0aGlzLmRpdmlzaW9uICogKHRoaXMudGVtcG8gLyA2MCkpKSArIHRoaXMuc3RhcnRUaWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBNSURJIGV2ZW50IG91dCB0byBsaXN0ZW5lci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH1cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJlbWl0RXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdEV2ZW50KGV2ZW50KSB7XG4gICAgICB0aGlzLnRyaWdnZXJQbGF5ZXJFdmVudCgnbWlkaUV2ZW50JywgZXZlbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgZXZlbnRzIHRvIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAtIE5hbWUgb2YgZXZlbnQgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IC0gQ2FsbGJhY2sgdG8gZmlyZSB3aGVuIGV2ZW50IGlzIGJyb2FkY2FzdC5cbiAgICAgKiBAcmV0dXJuIHtQbGF5ZXJ9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihwbGF5ZXJFdmVudCwgZm4pIHtcbiAgICAgIGlmICghdGhpcy5ldmVudExpc3RlbmVycy5oYXNPd25Qcm9wZXJ0eShwbGF5ZXJFdmVudCkpIHRoaXMuZXZlbnRMaXN0ZW5lcnNbcGxheWVyRXZlbnRdID0gW107XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzW3BsYXllckV2ZW50XS5wdXNoKGZuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGV2ZW50IHRvIHRyaWdnZXIgc3Vic2NyaWJlZCBjYWxsYmFja3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IC0gTmFtZSBvZiBldmVudC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gLSBEYXRhIHRvIGJlIHBhc3NlZCB0byBzdWJzY3JpYmVyIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge1BsYXllcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRyaWdnZXJQbGF5ZXJFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyUGxheWVyRXZlbnQocGxheWVyRXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KHBsYXllckV2ZW50KSkgdGhpcy5ldmVudExpc3RlbmVyc1twbGF5ZXJFdmVudF0uZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKGRhdGEgfHwge30pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGxheWVyO1xufSgpO1xuXG52YXIgaW5kZXggPSB7XG4gIFBsYXllcjogUGxheWVyLFxuICBVdGlsczogVXRpbHMsXG4gIENvbnN0YW50czogQ29uc3RhbnRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGV4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/midi-player-js/build/index.js\n");

/***/ })

};
;